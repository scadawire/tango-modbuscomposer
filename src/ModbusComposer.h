/*----- PROTECTED REGION ID(ModbusComposer.h) ENABLED START -----*/
//=============================================================================
//
// file :        ModbusComposer.h
//
// description : Include file for the ModbusComposer class
//
// project :     ModbusComposer
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#ifndef ModbusComposer_H
#define ModbusComposer_H

#include <tango.h>

namespace ModbusComposer_ns
{
class ModbusComposer;
}

#include "ExpParser.h"
#include "AttributeMap.h"
#include "ModbusComposerThread.h"

/*----- PROTECTED REGION END -----*/	//	ModbusComposer.h

#ifdef TANGO_LOG
	// cppTango after c934adea (Merge branch 'remove-cout-definition' into 'main', 2022-05-23)
	// nothing to do
#else
	// cppTango 9.3-backports and older
	#define TANGO_LOG       cout
	#define TANGO_LOG_INFO  cout2
	#define TANGO_LOG_DEBUG cout3
#endif // TANGO_LOG

/**
 *  ModbusComposer class description:
 *    A class to create dynamic attributes above a Modbus interface
 */


namespace ModbusComposer_ns
{
/*----- PROTECTED REGION ID(ModbusComposer::Additional Class Declarations) ENABLED START -----*/

//	Additional Class Declarations
	typedef struct {

	  ExpParser *ep;
	  Tango::DevState state;

	} STATEITEM;

  typedef struct {

     ExpParser *ep;

  } STATUSITEM;

	class DynCommand;
	class DynAttribute;
	class DynSpecAttribute;

/*----- PROTECTED REGION END -----*/	//	ModbusComposer::Additional Class Declarations

class ModbusComposer : public TANGO_BASE_CLASS
{

/*----- PROTECTED REGION ID(ModbusComposer::Data Members) ENABLED START -----*/

//	Add your own data members
private:
	Tango::DeviceProxy *selfDS;
	AttributeMap attMap;
	AttributeMap cmdMap;
	vector<STATEITEM> stateMap;
  vector<STATUSITEM> statusMap;

public:
  /**
   * Read modbus 16bit modbus register
   * @param cmd 0=>DefaultReadCommand, 1=>ReadHoldingRegister, 2=>ReadInputRegister
   * @param address Register address
   * @return Register
   */
	short reg(int cmd,short address);
  /**
   * Read modbus 16bit modbus registers
   * @param cmd 0=>DefaultReadCommand, 1=>ReadHoldingRegister, 2=>ReadInputRegister
   * @param address Register address
   * @param length Register number
   * @return Registers
   */
	vector<short> regs(int cmd,short address,int length);
  /**
   * Read modbus 16bit modbus register using DefaultReadCommand
   * @param address Register address
   * @return Register
   */
  short reg(short address);
  /**
   * Read modbus 16bit modbus registers using DefaultReadCommand
   * @param address Register address
   * @param length Register number
   * @return Registers
   */
  vector<short> regs(short address,int length);
	short coil(short address);
	vector<short> coils(short address,int length);
	void write_coil(short address,short value);
	void write_bit(short address,short bitIdx,short value);
	void write_reg(short address,short value);
	void write_regs(short address,vector<short> &value);
	double read_self_attribute(char *attName);

	virtual void read_dyn_attributes(Tango::Attribute &attr,DynAttribute *src);
	virtual void write_dyn_attributes(Tango::WAttribute &attr,DynAttribute *src);
	virtual void read_dynspec_attributes(Tango::Attribute &attr,DynSpecAttribute *src);
	virtual void write_dynspec_attributes(Tango::WAttribute &attr,DynSpecAttribute *src);

	// Handle to modbus device
	Tango::DeviceProxy *modbusDS;

	// Cache managememt
	ModbusComposerThread  *cacheThread;
	omni_mutex             cacheMutex;
  Tango::DevLong         cachePeriod;
	Tango::DevLong         cacheStartAddress;
	Tango::DevLong         cacheLength;
	vector<short>          cacheBuffer;
	Tango::DevLong         cacheCoilStartAddress;
	Tango::DevLong         cacheCoilLength;
	vector<short>          cacheCoilBuffer;
	bool                   cacheOK;
  string                 cacheError;	
	bool                   useCache;
	bool                   useCoilCache;

/*----- PROTECTED REGION END -----*/	//	ModbusComposer::Data Members

//	Device property data members
public:
	//	Modbus_name:	Name of the Modbus device
	std::string	modbus_name;
	//	DynamicAttributes:	List of dynacmic attributes
	//  See <a href=grammar.html>grammar.html</a>
	std::vector<std::string>	dynamicAttributes;
	//	DynamicCommands:	List of dynacmic attributes
	//  See <a href=grammar.html>grammar.html</a>
	std::vector<std::string>	dynamicCommands;
	//	DynamicStates:	State definitions (Default state is ON)
	//  See <a href=grammar.html>grammar.html</a>
	std::vector<std::string>	dynamicStates;
	//	DynamicStatus:	Status definitions
	//  See <a href=grammar.html>grammar.html</a>
	std::vector<std::string>	dynamicStatus;
	//	AddressOffset:	Integer offset added to Addresses in every Modbus command call
	Tango::DevLong	addressOffset;
	//	DefaultReadCommand:	Command use to read Modbus registers
	//  (eg. ReadHoldingRegisters)
	std::string	defaultReadCommand;
	//	CacheConfig:	Cache configuration, the read command is the DefaultReadCommand (if any)
	//  
	//  [0] = Start address
	//  [1] = Number of register
	//  [2] = Refresh period (ms)
	std::vector<Tango::DevLong>	cacheConfig;
	//	CoilCacheConfig:	Coil Cache configuration, the read can be only ReadMultipleCoilStatus
	//  
	//  [0] = Start address
	//  [1] = Number of coil
	//  [2] = Refresh period (ms)
	std::vector<Tango::DevLong>	coilCacheConfig;


//	Constructors and destructors
public:
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	ModbusComposer(Tango::DeviceClass *cl,std::string &s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	ModbusComposer(Tango::DeviceClass *cl,const char *s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device name
	 *	@param d	Device description.
	 */
	ModbusComposer(Tango::DeviceClass *cl,const char *s,const char *d);
	/**
	 * The device object destructor.
	 */
	~ModbusComposer();


//	Miscellaneous methods
public:
	/*
	 *	will be called at device destruction or at init command.
	 */
	void delete_device();
	/*
	 *	Initialize the device
	 */
	virtual void init_device();
	/*
	 *	Read the device properties from database
	 */
	void get_device_property();
	/*
	 *	Always executed method before execution command method.
	 */
	virtual void always_executed_hook();


//	Attribute methods
public:
	//--------------------------------------------------------
	/*
	 *	Method     : ModbusComposer::read_attr_hardware()
	 *	Description: Hardware acquisition for attributes.
	 */
	//--------------------------------------------------------
	virtual void read_attr_hardware(std::vector<long> &attr_list);


	//--------------------------------------------------------
	/**
	 *	Method     : ModbusComposer::add_dynamic_attributes()
	 *	Description: Add dynamic attributes if any.
	 */
	//--------------------------------------------------------
	void add_dynamic_attributes();




//	Command related methods
public:
	/**
	 *	Command State related method
	 *	Description: This command gets the device state (stored in its device_state data member) and returns it to the caller.
	 *
	 *	@returns Device state
	 */
	virtual Tango::DevState dev_state();

//	Dynamic commands methods
public:
	/**
	 *	Command DynCommand related method
	 *
	 *
	 */
	virtual void dyn_command(Tango::Command &command);
	virtual bool is_DynCommand_allowed(const CORBA::Any &any);
	void add_DynCommand_dynamic_command(std::string cmdname, bool device);
	void remove_DynCommand_dynamic_command(std::string cmdname);

	//--------------------------------------------------------
	/**
	 *	Method     : ModbusComposer::add_dynamic_commands()
	 *	Description: Add dynamic commands if any.
	 */
	//--------------------------------------------------------
	void add_dynamic_commands();

/*----- PROTECTED REGION ID(ModbusComposer::Additional Method prototypes) ENABLED START -----*/

//	Additional Method prototypes

/*----- PROTECTED REGION END -----*/	//	ModbusComposer::Additional Method prototypes
};

/*----- PROTECTED REGION ID(ModbusComposer::Additional Classes Definitions) ENABLED START -----*/

//	Additional Classes Definitions

/*----- PROTECTED REGION END -----*/	//	ModbusComposer::Additional Classes Definitions

}	//	End of namespace

#endif   //	ModbusComposer_H
